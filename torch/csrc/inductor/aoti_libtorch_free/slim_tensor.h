#pragma once

#include <cassert>
#include <cstdint>
#include <cstring>
#include <stdexcept>
#include <utility>

#include <torch/csrc/inductor/aoti_libtorch_free/storage.h>
#include <torch/csrc/inductor/aoti_libtorch_free/utils.h>

#ifdef USE_CUDA
#include <torch/csrc/inductor/aoti_libtorch_free/cuda/utils.h>
#endif

namespace aoti::libtorch_free {

class SlimTensor {
 public:
  SlimTensor(
      Storage&& storage,
      IntArrayRef sizes,
      IntArrayRef strides,
      ScalarType dtype,
      int64_t storage_offset = 0)
      : storage_(std::move(storage)),
        sizes_(sizes),
        strides_(strides),
        dtype_(dtype),
        numel_(compute_numel(sizes)),
        nbytes_(compute_nbytes(sizes, dtype)),
        storage_offset_(storage_offset) {}

  SlimTensor() {
    throw std::runtime_error("SlimTensor::SlimTensor() should not be called\n");
  }
  SlimTensor(const SlimTensor&) = default;
  SlimTensor& operator=(const SlimTensor&) = default;
  SlimTensor(SlimTensor&&) = default;
  SlimTensor& operator=(SlimTensor&&) = default;

  ~SlimTensor() = default;

  void reset() {
    // Decrement the refcount of the storage
    storage_.reset();
  }

  // Accessors
  Storage storage() const {
    return storage_;
  }

  IntArrayRef sizes() const {
    return sizes_;
  }

  int64_t size(size_t dim) const {
    return sizes_[dim];
  }

  IntArrayRef strides() const {
    return strides_;
  }

  int64_t stride(size_t dim) const {
    return strides_[dim];
  }

  ScalarType dtype() const {
    return dtype_;
  }

  const Device& device() const {
    return storage_->device();
  }

  DeviceType device_type() const {
    return storage_->device_type();
  }

  DeviceIndex device_index() const {
    return storage_->device_index();
  }

  int64_t storage_offset() const {
    return storage_offset_;
  }

  size_t numel() const {
    return numel_;
  }

  size_t nbytes() const {
    return nbytes_;
  }

  size_t dim() const {
    return sizes_.size();
  }

  void* data_ptr() const {
    return storage_->data();
  }

  SlimTensor as_strided_(
      IntArrayRef sizes,
      IntArrayRef strides,
      int64_t storage_offset) {
    sizes_ = sizes;
    strides_ = strides;
    storage_offset_ = storage_offset;
    return *this;
  }

  SlimTensor copy_(const SlimTensor& other) {
    storage_->clone(other.storage(), other.nbytes_, other.storage_offset());
    return *this;
  }

  SlimTensor to(const Device& device) const {
    // Does not mutate the current tensor, but returns a new tensor
    if (device == storage_->device()) {
      return *this;
    }
    Storage new_storage(new MaybeOwningStorage(nbytes_, device));
    new_storage->clone(storage_, nbytes_, storage_offset_);
    return SlimTensor(
        std::move(new_storage), sizes_, strides_, dtype_, storage_offset_);
  }

  SlimTensor to(ScalarType dtype) const {
    // Does not mutate the current tensor, but returns a new tensor
    if (dtype == dtype_) {
      return *this;
    }
    if (SCALAR_TYPE_TO_BYTESIZE[static_cast<int32_t>(dtype_)] ==
        SCALAR_TYPE_TO_BYTESIZE[static_cast<int32_t>(dtype)]) {
      // Same size, just reinterpret the dtype
      Storage tmp_storage = storage_;
      return SlimTensor(
          std::move(tmp_storage), sizes_, strides_, dtype, storage_offset_);
    }
    if (dtype_ == ScalarType::_bfloat16 && dtype == ScalarType::_float32 &&
        storage_->device_type() == DeviceType::cuda) {
      // bfloat16 -> float32
      // Only implemented this for CUDA to make llama3 example work
#ifdef USE_CUDA
      Storage new_storage(new MaybeOwningStorage(
          compute_nbytes(sizes_, dtype), storage_->device()));
      cuda_convertBFloat16ToFloat32(
          storage_->data(), new_storage->data(), numel_);
      return SlimTensor(
          std::move(new_storage), sizes_, strides_, dtype, storage_offset_);
#else
      throw std::runtime_error("CUDA is not enabled");
#endif
    }
    throw std::runtime_error("Unsupported dtype conversion");
  }

 private:
  // device_type_ and device_index_ are stored in Device in Storage
  Storage storage_;
  // Sizes and strides are expected to be static and generated by AOTI
  IntArrayRef sizes_;
  IntArrayRef strides_;
  ScalarType dtype_;
  size_t numel_;
  size_t nbytes_;
  int64_t storage_offset_;
};

// The returned SlimTensor is owned by the caller
inline SlimTensor create_empty_tensor(
    IntArrayRef sizes,
    IntArrayRef strides,
    ScalarType dtype,
    const Device& device = CPU_DEVICE,
    int64_t storage_offset = 0) {
  size_t nbytes = compute_nbytes(sizes, dtype);
  Storage storage(new MaybeOwningStorage(nbytes, device));
  return SlimTensor(std::move(storage), sizes, strides, dtype, storage_offset);
}

inline SlimTensor create_tensor_from_blob(
    void* data,
    IntArrayRef sizes,
    IntArrayRef strides,
    ScalarType dtype,
    const Device& device = CPU_DEVICE,
    int64_t storage_offset = 0) {
  if (data == nullptr) {
    throw std::runtime_error("data pointer can not be nullptr");
  }
  Storage storage(new MaybeOwningStorage(data, device));
  return SlimTensor(std::move(storage), sizes, strides, dtype, storage_offset);
}
} // namespace aoti::libtorch_free
